<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roblox Multi Group Overlap Checker</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7c3aed;--muted:#94a3b8;--glass: rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071022 0%, #071428 60%);color:#e6eef8;padding:28px;box-sizing:border-box}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:var(--card);border-radius:14px;padding:18px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 18px;color:var(--muted)}

    .row{display:flex;gap:10px}
    .col{flex:1}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=text], textarea{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:inherit;font-size:14px;box-sizing:border-box}
    textarea{min-height:120px;resize:vertical}
    button{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent),#5b21b6);color:white;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}

    .controls{display:flex;gap:10px;align-items:center}
    .progress{height:12px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
    .progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,#7c3aed,#60a5fa);transition:width .2s}

    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,0.02);text-align:left;font-size:13px;vertical-align:middle}
    th{color:var(--muted);font-weight:600;font-size:12px}
    a{color:#9ad4ff;text-decoration:none}

    .meta{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px}
    .chip{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:999px;font-size:13px}

    footer{margin-top:12px;color:var(--muted);font-size:13px}

    .small{font-size:12px;color:var(--muted)}
    @media (max-width:720px){.row{flex-direction:column}.controls{flex-direction:column;align-items:stretch}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Main vs Blacklisted Group Overlap Checker</h1>
      <p class="lead">Enter one main Roblox Group ID and up to 10 blacklisted group IDs (comma, space or newline separated). The tool will list only users who are in the main group and in at least one blacklisted group. Uses the public Roblox Groups API (requests relayed through a CORS proxy so it works on GitHub Pages).</p>

      <div class="row">
        <div class="col">
          <label for="groupMain">Main Group ID</label>
          <input id="groupMain" type="text" placeholder="e.g. 13783772" value="13783772">
        </div>
        <div class="col">
          <label for="groupList">Blacklisted Group IDs (max 10)</label>
          <textarea id="groupList" placeholder="e.g. 12812724, 9876543, 1234567"></textarea>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="controls">
        <button id="startBtn">Check Overlap</button>
        <button id="exportBtn" class="secondary" disabled>Export CSV</button>
        <button id="copyBtn" class="secondary" disabled>Copy Profile Links</button>
        <div style="flex:1"></div>
        <div style="min-width:260px">
          <label style="font-size:12px;color:var(--muted);margin-bottom:6px;display:block">Progress</label>
          <div class="progress"><i id="bar"></i></div>
          <div class="small" id="progressText">Idle</div>
        </div>
      </div>

      <div class="meta">
        <div class="chip">Main group members: <strong id="countMain">—</strong></div>
        <div class="chip">Blacklists total members: <strong id="countBlack">—</strong></div>
        <div class="chip">Matches: <strong id="countBoth">—</strong></div>
      </div>

      <div id="resultsWrap">
        <table id="resultsTable" style="display:none">
          <thead><tr><th>#</th><th>Username</th><th>UserID</th><th>Blacklisted Groups (name + id)</th></tr></thead>
          <tbody id="resultsBody"></tbody>
        </table>
      </div>

      <footer>
        Note: this page uses <code>https://corsproxy.io/?</code> to add CORS headers so it works when hosted on GitHub Pages. Requests may be a bit slow. Made by PaulusKernmagne <3
      </footer>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const exportBtn = document.getElementById('exportBtn');
    const copyBtn = document.getElementById('copyBtn');
    const bar = document.getElementById('bar');
    const progressText = document.getElementById('progressText');
    const countMain = document.getElementById('countMain');
    const countBlack = document.getElementById('countBlack');
    const countBoth = document.getElementById('countBoth');
    const resultsTable = document.getElementById('resultsTable');
    const resultsBody = document.getElementById('resultsBody');

    // Proxy used so GitHub Pages can fetch Roblox API (replace with your own for reliability)
    const proxy = "https://corsproxy.io/?";

    function setProgress(p){
      bar.style.width = Math.max(0, Math.min(100,p)) + '%';
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

    // Fetch group basic info (name) using groups API
    async function fetchGroupInfo(groupId){
      const url = `${proxy}https://groups.roblox.com/v1/groups/${encodeURIComponent(groupId)}`;
      const res = await fetch(url); // allow throwing to catch upstream
      if (!res.ok) throw new Error(`Failed to fetch group ${groupId}: ${res.status}`);
      return res.json();
    }

    // Fetch all members of a group (paged)
    async function fetchGroupMembers(groupId, onProgressPerGroup){
      const members = [];
      let cursor = null;
      const limit = 100;
      const base = `${proxy}https://groups.roblox.com/v1/groups/${groupId}/users?limit=${limit}`;

      while (true){
        const url = base + (cursor ? `&cursor=${encodeURIComponent(cursor)}` : '');
        let res;
        try {
          res = await fetch(url);
        } catch(e){
          throw new Error('Network or CORS error: ' + (e && e.message ? e.message : e));
        }
        if (!res.ok) {
          const txt = await res.text().catch(()=>res.statusText);
          throw new Error(`Roblox API error ${res.status}: ${txt}`);
        }
        const data = await res.json();
        if (!Array.isArray(data.data)) break;
        for (const entry of data.data){
          const u = entry.user || entry;
          members.push({ id: u.userId, username: u.username || u.displayName || ('id:'+u.userId) });
        }
        if (onProgressPerGroup) onProgressPerGroup(members.length);
        cursor = data.nextPageCursor || null;
        if (!cursor) break;
        await new Promise(r => setTimeout(r, 250)); // polite delay
      }
      return members;
    }

    function renderResults(list){
      resultsBody.innerHTML = '';
      list.forEach((u, idx) => {
        const tr = document.createElement('tr');
        const groupsHtml = escapeHtml(u.groups.map(g=>`${g.name} (${g.id})`).join(', '));
        tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(u.username)}</td><td>${u.id}</td><td>${groupsHtml}</td>`;
        resultsBody.appendChild(tr);
      });
      resultsTable.style.display = list.length ? '' : 'none';
    }

    function toCSV(rows){
      const hdr = ['username','userid','groups'];
      const lines = [hdr.join(',')];
      for (const r of rows){
        const groupsTxt = r.groups.map(g=>`${g.name} (${g.id})`).join('; ');
        lines.push([`"${r.username.replace(/"/g,'""')}"`, r.id, `"${groupsTxt.replace(/"/g,'""')}"`].join(','));
      }
      return lines.join('\n');
    }

    startBtn.addEventListener('click', async () => {
      const mainId = document.getElementById('groupMain').value.trim();
      const rawList = document.getElementById('groupList').value.trim();
      if (!mainId || !rawList){ alert('Please enter the main group ID and at least one blacklisted group ID.'); return; }

      // Parse blacklisted IDs, dedupe, cap at 10 and remove mainId if accidentally included
      const parts = rawList.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
      const uniq = Array.from(new Set(parts)).filter(id => id !== mainId);
      if (uniq.length === 0){ alert('Please provide at least one blacklisted group ID different from the main group.'); return; }
      const blackIds = uniq.slice(0, 10);

      startBtn.disabled = true;
      exportBtn.disabled = true;
      copyBtn.disabled = true;
      setProgress(0);
      progressText.textContent = 'Starting...';
      resultsBody.innerHTML = ''; resultsTable.style.display = 'none';
      countMain.textContent = '—'; countBlack.textContent = '—'; countBoth.textContent = '—';

      try {
        // 1) Fetch main group info & members
        progressText.textContent = `Fetching main group (${mainId}) info...`;
        const mainInfo = await fetchGroupInfo(mainId).catch(e => { throw new Error('Failed to fetch main group info: ' + e.message); });
        const mainName = mainInfo && mainInfo.name ? mainInfo.name : `Group ${mainId}`;

        progressText.textContent = `Fetching members of main group (${mainName})...`;
        const mainMembers = await fetchGroupMembers(mainId, (n) => {
          progressText.textContent = `Main group members fetched: ${n}`;
          setProgress(5);
        });

        countMain.textContent = mainMembers.length;

        // Build map of main group members for quick lookup
        const mainMap = new Map();
        for (const m of mainMembers) mainMap.set(String(m.id), { id: m.id, username: m.username });

        // 2) For each blacklisted group, fetch info and members; while fetching, check membership against mainMap
        const blackGroupsInfo = [];
        let blackTotalCount = 0;
        const userMatches = new Map(); // userid -> {id, username, groups: [{id,name}]}

        let groupsDone = 0;
        const totalGroups = blackIds.length;

        for (const gid of blackIds){
          progressText.textContent = `Fetching blacklisted group ${gid} info... (${groupsDone}/${totalGroups})`;
          let info;
          try{
            info = await fetchGroupInfo(gid);
          }catch(e){
            // if a group fetch fails, continue but mark name as unknown
            info = { id: gid, name: `Group ${gid}` };
          }
          const gname = info && info.name ? info.name : `Group ${gid}`;
          blackGroupsInfo.push({ id: gid, name: gname });

          progressText.textContent = `Fetching members of ${gname}... (${groupsDone}/${totalGroups})`;
          // per-group progress callback: update progress bar in relation to groups done
          const members = await fetchGroupMembers(gid, (n) => {
            // compute progress roughly: main step small (5%), black groups share 90%
            const base = 5;
            const perGroupShare = 90 / totalGroups;
            const p = base + (groupsDone * perGroupShare) + Math.min(perGroupShare, Math.round((n/2000) * perGroupShare));
            setProgress(p);
            progressText.textContent = `Fetching members of ${gname}: ${n} fetched...`;
          });

          blackTotalCount += members.length;

          // Check members against mainMap and record overlaps
          for (const m of members){
            const key = String(m.id);
            if (mainMap.has(key)){
              if (!userMatches.has(key)){
                const u = mainMap.get(key);
                userMatches.set(key, { id: u.id, username: u.username, groups: [{ id: gid, name: gname }]});
              } else {
                userMatches.get(key).groups.push({ id: gid, name: gname });
              }
            }
          }

          groupsDone++;
          // update progress between groups
          const progressAfter = 5 + Math.round((groupsDone / totalGroups) * 90);
          setProgress(progressAfter);
          progressText.textContent = `Done with ${gname} (${groupsDone}/${totalGroups})`;
          await new Promise(r => setTimeout(r, 200)); // tiny pause
        }

        countBlack.textContent = blackTotalCount;

        // Build final list: only users who are in main group and at least one blacklisted group (userMatches already has that)
        const overlapList = Array.from(userMatches.values()).sort((a,b) => a.username.localeCompare(b.username, undefined, {sensitivity:'base'}));

        countBoth.textContent = overlapList.length;
        renderResults(overlapList);

        exportBtn.disabled = overlapList.length === 0;
        copyBtn.disabled = overlapList.length === 0;

        // export CSV
        exportBtn.onclick = () => {
          const csv = toCSV(overlapList);
          const blob = new Blob([csv], {type:'text/csv'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `overlap_main${mainId}_blacklist.csv`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        };

        // copy profile links
        copyBtn.onclick = async () => {
          const text = overlapList.map(o => `https://www.roblox.com/users/${o.id}/profile`).join('\n');
          try {
            await navigator.clipboard.writeText(text);
            alert('Profile links copied to clipboard');
          } catch(e){
            prompt('Copy these links:', text);
          }
        };

        progressText.textContent = 'Complete';
        setProgress(100);

      } catch (err) {
        console.error(err);
        alert('Error: ' + (err && err.message ? err.message : err));
        progressText.textContent = 'Error';
        setProgress(100);
      } finally {
        startBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
